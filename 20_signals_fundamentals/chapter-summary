Chapter Summary
---------------


A signal is a notification that some kind of event has occured, and many may be sent to a process by the kernel, by another process, or by itself. There is a range of standard signal types, each of which has a unique number and purpose.

Signal delivery is typically asynchronous, meaning that the point at which the signal interrupts execution of the process is unpredictable. In some cases (e.g., hardware-generated signals), signals are delivered synchronously, meaning that delivery occurs predictably and reproducibly at a certain point in the execution of a program.

By default, a signal either is ignored, terminates a process (with or without a core dump), stops a running process, or restarts a stopped process. The particular default action depends on the signal type. Alternatively, a program can use signal() or sigaction() to explicitly ignore a signal or to establish a programmer-defined signal handler function that is invoked when the signal is delivered. For portability reasons, establishing a signal handler is best performed using sigaction().

A process (with suitable permissions) can send a signal to another process using kill(). Sending the null signal (0) is a way of determining if a particular process ID is in use.

Each process has a signal mask, which is the set of signals whose delivery is currently blocked. Signals can be added to and removed from the signal mask using sigprocmask().

If a signal is received while it is blocked, then it remains pending until it is unblocked. Standard signals can't be queued; that is, a signal can be marked as pending (and thus later delivered) only once. A process can use the sigpending() system call to retrieve a signal set (a data structure used to represent multiple different signals) identifying the signals that is has pending.

The sigaction() system call provides more control and flexibility than signal() when setting the disposition of a signal. First, we can specify a set of additional signals to be blocked when a handler is invoked. In addition, various flags can be used to control the actions that occur when a signal handler is invoked. For example, there are flags that select the older unreliable signal semantics (not blocking the signal causing invocation of a handler, and having the disposition of the signal reset to its default before the handler is called).

Using pause(), a process can suspend execution until a signal arrives.


Notes:
------

Signal Set
- sigaction() and sigprocmask() allow a program to specify a group of signals that are to be blocked by a process, while sigpending() returns a group of signals that are currently pending for a process
- multiple signals are represented using a data structure called a signals set, provided by the system data type sigset_t
- sigemptyset() initializes a signal set to contain no members
- sigfillset() initializes a set to contain all signals (including all realtime signals)
- after initialization, individual signals can be added to a set using sigaddset() and removed using sigdelset()
- sigismember() is used to test for membership of a set
- sigandset() places the intersection of the sets left and right in the set dest;
- sigorset() places the union of the sets left and right in the set dest; and
- sigisemptyset() returns true if set contains no signals

Signal Mask (Blocking Signal Delivery)

-for each process, the kernel maintains a signal mask - a set of signals whose delivery to the process is currently blocked
- if a signal that is currently blocked is sent to a process, delivery of that signal is delayed until it is unblocked by being removed from the process signal mask
- a signal may be added to the signal mask in the following ways:
- when a signal handler is invoked, the signal that caused its invocation can be automatically added to the signal mask. This depends on the flags used when the handler is established using sigaction()
- when the signal handler is established with sigaction(), it is possible to specify an additional set of signals that are to be blocked when the handler is invoked
- the sigprocmask() system call can be used at any time to explicitly add signals to, and remove signals from, the signal mask

- we use sigprocmask() to change the process signal mask, to retreive the existing mask or both

Changing Signal Disposition: sigaction()
- sigaction() is the alternative to signal()
- allows us to retrieve the disposition of a signal without changing it, and to set various attributes controlling precisely what happens when a signal handler is invoked
- sigaction() is more portable than signal()
- definition is
#include <signal.h>

int signal(int sig, const struct sigaction *act, struct sigaction *oldact );
- the sig argument identifies the signal whose disposition we want to retrieve or change. This argument can be any signal except SIGKILL or SIGSTOP
- the act argument is a pointer to a structure specifying a new disposition for the signal. If we are interested only in finding the existing disposition of a signal 